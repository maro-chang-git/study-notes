![[Pasted image 20250630180243.png]]

## Stack
Stack follows LIFO(Last-in, first-out) principle

Basic Operations
`push(item)`             -   Add an item to the top
`pop()`                       -  Remove and return the top item
`peek()`                     -  Return the top without removing it
`is_empty()`             -  Return `true` if size = 0
`len()`                     

### Stack (Using list)
```python
stack = []

#Push
stack.append("apple")
stack.append("banana")

#Peek
print(stack[-1])

#Pop
print(stack.pop())

#Check if empty
print(len(stack) == 0)
```

### Use cases

#### Backtracking
Problem: Generate all subsets of a list
```python
#Given list [1,2,3], generate:

[]
[1]
[2]
[3]
[1, 2]
[1, 3]
[2, 3]
[1, 2, 3]

```

```python
def generate_subsets(nums):
    result = []

    def backtrack(index, path):
        if index == len(nums):
            result.append(path[:])  # Make a copy
            return
        
        # 1. Include nums[index]
        path.append(nums[index])
        backtrack(index + 1, path)

        # 2. Exclude nums[index] (backtrack)
        path.pop()
        backtrack(index + 1, path)

    backtrack(0, [])
    return result

```
#### DFS
Problem: visit all connected `1` cells in a grid. (0 = water, 1 = land)
```python
#Example Grid:
grid = [
	[1,1,0,0],
	[0,1,0,1],
	[0,0,1,1],
	[1,0,0,0]
]
```

 DFS logic:
 - Use a stack to explore neighbors
 - Move in 4 directions: up down left right
 - Track visited cells to avoid cycles

```python
def dfs_matrix(grid, start_row, start_col):
	rows, cols = len(grid), len(grid[0])
	visited = set()
	stack = [(start_row, start_col)]

	directions = [(-1,0), (1,0), (0, -1), (0,1)]       #up, down, left, right

	while stack:            #stack not empty
		r,c = stack.pop()

		#Check if visited
		if (r,c) in visited:
			continue
		
		#boundary and value check
		if r < 0 or r >= rows or c < 0 or c >= cols:
			continue
		#Check land-water
		if grid[r][c] == 0:
			continue

		print(f"Visited: ({r},{c})")
		visited.add((r,c))

		for dr, dc in directions:
			stack.append((r + dr, c + dc))

#Start DFS
dfs_matrix(grid, 0, 0)  # Start at top-left (0,0)
```

#### Undo/Redo
Track recent action

#### Browsing History

#### Parentheses Check
Match opening & closing symbols

#### Expression Eval
Postfix / Prefix / infix evaluation



### Custom Stack Class 
```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop() if not self.is_empty() else None

    def peek(self):
        return self.items[-1] if not self.is_empty() else None

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)
```


## Queue