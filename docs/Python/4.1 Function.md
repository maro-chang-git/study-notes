Why use functions?
- It's a reusable block of code.
- Break code into smaller pieces
- Easier to maintained

***Keywords***:
`def`             -     define a function
`return`       -     return value
`yield`         -     return a value from a generator
`lamda`         -     create an inline function                  `lamda x:= x +1`
`global`       -     declare a variable as global
`nonlocal`   -     declares a variable from outer function (but not global)
`pass`           -     empty function                               `def todo(): pass`
`async`         -     define an asynchronous function
`await`         -     waits for an async operation to complete

Other
`""" description """`    - Docstring
`->`                                      - Annotation, data type of output
```python
def f(x) -> int:
	pass
```

### Def - define a function
```python
def greet():
	print("Hello, ")

greet()

def my_func:
	pass
```

### Return multiple
```python
#Return single
def add(a,b):
	return a+b

#Return multiple
def get_stats(nums):
	return min(nums), max(nums), sum(nums)

min_val, max_val, total = get_stat([1, 2, 3])
```

### Parameters
```python
#With parameters
def add(a,b):
	return a+b
```

#### Default parameter
```python
def greet(name="client"):
	print(f"Hi, {name}")

greet()                     #Hi, client
greet("Bob")                #Hi, Bob
```

#TODO
pass list as parameters
pass map as parameters

### Pass
```python
def todo():
    pass  # To be implemented later
```
### Async & Await
#TODO 


### Recursion
Fibonacci:
`[0, 1, 1, 2, 3, 5, 8, 13, 21]`

```python
#Time complexity: O(2^n)
def fib(n):
	#if n is 1 or 0
	if n <= 1:                         #Base case
		return n
	else
		return fibo(n-1) + fibo(n-2)   #Recursive case
```

#### Recursion with memory
Create memo dictionary
```python
#Time complexity: O(n)
memo = {}

def fib(n):

	if n in memo:
		return memo[n]

	if n <= 1:
		return n

	memo[n] = fib(n-1) + fib(n-2)
	return memo[n]
```